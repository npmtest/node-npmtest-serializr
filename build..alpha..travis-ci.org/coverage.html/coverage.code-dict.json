{"/home/travis/build/npmtest/node-npmtest-serializr/test.js":"/* istanbul instrument in package npmtest_serializr */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-serializr/lib.npmtest_serializr.js":"/* istanbul instrument in package npmtest_serializr */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_serializr = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_serializr = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-serializr/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-serializr && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_serializr */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_serializr\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_serializr.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_serializr.rollup.js'] =\n            local.assetsDict['/assets.npmtest_serializr.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_serializr.__dirname + '/lib.npmtest_serializr.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-serializr/node_modules/serializr/serializr.js":"(function(g) {\n    \"use strict\"\n\n    function mrFactory() {\n        // Indicate properties should be skipped\n        var SKIP = typeof Symbol !== \"undefined\" ? Symbol(\"SKIP\") : { SKIP: true }\n/*\n * Generic utility functions\n */\n        function GUARDED_NOOP(err) {\n            if (err) // unguarded error...\n                throw new Error(err)\n        }\n\n        function  once(fn) {\n            var fired = false\n            return function() {\n                if (!fired) {\n                    fired = true\n                    return fn.apply(null, arguments)\n                }\n                invariant(false, \"callback was invoked twice\")\n            }\n        }\n\n        function invariant(cond, message) {\n            if (!cond)\n                throw new Error(\"[serializr] \" + (message || \"Illegal State\"))\n        }\n\n        function parallel(ar, processor, cb) {\n            // TODO: limit parallelization?\n            if (ar.length === 0)\n                return void cb(null, [])\n            var left = ar.length\n            var resultArray = []\n            var failed = false\n            var processorCb = function(idx, err, result) {\n                if (err) {\n                    if (!failed) {\n                        failed = true\n                        cb(err)\n                    }\n                } else {\n                    resultArray[idx] = result\n                    if (--left === 0)\n                        cb(null, resultArray)\n                }\n            }\n            ar.forEach(function (value, idx) {\n                processor(value, processorCb.bind(null, idx))\n            })\n        }\n\n        function isPrimitive(value) {\n            if (value === null)\n                return true\n            return typeof value !== \"object\" && typeof value !== \"function\"\n        }\n\n/*\n * ## Managing model schemas\n */\n        /**\n         * JSDOC type defintions for usage w/o typescript.\n         * @typedef {object} PropSchema\n         * @property {serializerFunction} serializer\n         * @property {deserializerFunction} deserializer\n         * @property {boolean} identifier\n         *\n         * @typedef {object} PropertyDescriptor\n         * @param {*} value\n         * @param {boolean} writeable\n         * @param {Function|undefined} get\n         * @param {Function|undefined} set\n         * @param {boolean} configurable\n         * @param {boolean} enumerable\n         *\n         * @callback serializerFunction\n         * @param {*} sourcePropertyValue\n         * @returns any - serialized object\n         *\n         *\n         * @callback deserializerFunction\n         * @param {*} jsonValue\n         * @param {cpsCallback} callback\n         * @param {Context} context\n         * @param {*} currentPropertyValue\n         * @returns void\n         *\n         * @callback RegisterFunction\n         * @param {*} id\n         * @param {object} target\n         * @param {Context} context\n         *\n         * @callback cpsCallback\n         * @param {*} result\n         * @param {*} error\n         * @returns void\n         *\n         * @callback RefLookupFunction\n         * @param {string} id\n         * @param {cpsCallback} callback\n         * @returns void\n         *\n         * @typedef {object} ModelSchema\n         * @param factory\n         * @param props\n         * @param targetClass\n         */\n\n        /**\n         * Creates a model schema that (de)serializes from / to plain javascript objects.\n         * Its factory method is: `() => ({})`\n         *\n         * @example\n         * var todoSchema = createSimpleSchema({\n         *   title: true,\n         *   done: true\n         * });\n         *\n         * var json = serialize(todoSchema, { title: \"Test\", done: false })\n         * var todo = deserialize(todoSchema, json)\n         *\n         * @param {object} props property mapping,\n         * @returns {object} model schema\n         */\n        function createSimpleSchema(props) {\n            return {\n                factory: function() {\n                    return {}\n                },\n                props: props\n            }\n        }\n\n        /**\n         * Creates a model schema that (de)serializes an object created by a constructor function (class).\n         * The created model schema is associated by the targeted type as default model schema, see setDefaultModelSchema.\n         * Its factory method is `() => new clazz()` (unless overriden, see third arg).\n         *\n         * @example\n         * function Todo(title, done) {\n         *   this.title = title;\n         *   this.done = done;\n         * }\n         *\n         * createModelSchema(Todo, {\n         *   title: true,\n         *   done: true\n         * })\n         *\n         * var json = serialize(new Todo(\"Test\", false))\n         * var todo = deserialize(Todo, json)\n         *\n         * @param {constructor|class} clazz class or constructor function\n         * @param {object} props property mapping\n         * @param {function} factory optional custom factory. Receives context as first arg\n         * @returns {object} model schema\n         */\n        function createModelSchema(clazz, props, factory) {\n            invariant(clazz !== Object, \"one cannot simply put define a model schema for Object\")\n            invariant(typeof clazz === \"function\", \"expected constructor function\")\n            var model = {\n                targetClass: clazz,\n                factory: factory || function() {\n                    return new clazz()\n                },\n                props: props\n            }\n            // find super model\n            if (clazz.prototype.constructor !== Object) {\n                var s = getDefaultModelSchema(clazz.prototype.constructor)\n                if (s && s.targetClass !== clazz)\n                    model.extends = s\n            }\n            setDefaultModelSchema(clazz, model)\n            return model\n        }\n\n        /**\n         * Decorator that defines a new property mapping on the default model schema for the class\n         * it is used in.\n         *\n         * When using typescript, the decorator can also be used on fields declared as constructor arguments (using the `private` / `protected` / `public` keywords).\n         * The default factory will then invoke the constructor with the correct arguments as well.\n         *\n         * @example\n         * class Todo {\n         *   @serializable(primitive())\n         *   title;\n         *\n         *   @serializable // shorthand for primitves\n         *   done;\n         *\n         *   constructor(title, done) {\n         *     this.title = title;\n         *     this.done = done;\n         *   }\n         * }\n         *\n         * var json = serialize(new Todo(\"Test\", false))\n         * var todo = deserialize(Todo, json)\n         *\n         * @param arg1\n         * @param arg2\n         * @param arg3\n         * @returns {PropertyDescriptor}\n         */\n        function serializable(arg1, arg2, arg3) {\n            if (arguments.length === 1) {\n                // decorated with propSchema\n                var propSchema = arg1 === true ? _defaultPrimitiveProp : arg1\n                invariant(isPropSchema(propSchema), \"@serializable expects prop schema\")\n                return serializableDecorator.bind(null, propSchema)\n            } else {\n                // decorated without arguments, treat as primitive\n                return serializableDecorator(primitive(), arg1, arg2, arg3)\n            }\n        }\n\n        // Ugly way to get the parameter names since they aren't easily retrievable via reflection\n        var STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg\n        var ARGUMENT_NAMES = /([^\\s,]+)/g\n        function getParamNames(func) {\n            var fnStr = func.toString().replace(STRIP_COMMENTS, \"\")\n            var result = fnStr.slice(fnStr.indexOf(\"(\")+1, fnStr.indexOf(\")\")).match(ARGUMENT_NAMES)\n            if(result === null)\n                result = []\n            return result\n        }\n\n        function serializableDecorator(propSchema, target, propName, descriptor) {\n            invariant(arguments.length >= 2, \"too few arguments. Please use @serializable as property decorator\")\n            // Fix for @serializable used in class constructor params (typescript)\n            var factory\n            if (propName === undefined && typeof target === \"function\"\n                && target.prototype\n                && descriptor !== undefined && typeof descriptor === \"number\") {\n                invariant(isPropSchema(propSchema), \"Constructor params must use alias(name)\")\n                invariant(propSchema.jsonname, \"Constructor params must use alias(name)\")\n                var paramNames = getParamNames(target)\n                if (paramNames.length >= descriptor) {\n                    propName = paramNames[descriptor];\n                    propSchema.paramNumber = descriptor\n                    descriptor = undefined\n                    target = target.prototype\n                    // Create a factory so the constructor is called properly\n                    factory = function(context) {\n                        function F(args) {\n                            return target.constructor.apply(this, args)\n                        }\n                        F.prototype = target.constructor.prototype\n                        var params = []\n                        for (var i = 0; i < target.constructor.length; i++) {\n                          Object.keys(context.modelSchema.props).forEach(function (key) {\n                            var prop = context.modelSchema.props[key];\n                            if (prop.paramNumber === i) {\n                              params[i] = context.json[prop.jsonname];\n                            }\n                          });\n                        }\n                        return new F(params)\n                    }\n                }\n            }\n            invariant(typeof propName === \"string\", \"incorrect usage of @serializable decorator\")\n            var info = getDefaultModelSchema(target)\n\n            if (!info || !target.constructor.hasOwnProperty(\"serializeInfo\"))\n                info = createModelSchema(target.constructor, {}, factory)\n            if (info && info.targetClass !== target.constructor)\n                // fixes typescript issue that tends to copy fields from super constructor to sub constructor in extends\n                info = createModelSchema(target.constructor, {}, factory)\n            info.props[propName] = propSchema\n            // MWE: why won't babel work without?\n            if (descriptor && !descriptor.get && !descriptor.set)\n                descriptor.writable = true\n            return descriptor\n        }\n\n        /**\n         * The `serializeAll` decorator can be used on a class to signal that all primitive properties should be serialized automatically.\n         *\n         * @example\n         * \\@serializeAll\n         * class Store {\n         *     a = 3\n         *     b\n         * }\n         *\n         * const store = new Store\n         * store.c = 5\n         * store.d = {}\n         * t.deepEqual(serialize(store), { a: 3, b: undefined, c: 5})\n         */\n        function serializeAll(target) {\n            invariant(arguments.length === 1 && typeof target === \"function\", \"@serializeAll can only be used as class decorator\")\n\n            var info = getDefaultModelSchema(target)\n            if (!info || !target.hasOwnProperty(\"serializeInfo\")) {\n                info = createModelSchema(target, {})\n                setDefaultModelSchema(target, info)\n            }\n\n            getDefaultModelSchema(target).props[\"*\"] = true\n            return target\n        }\n\n        /**\n         * Returns the standard model schema associated with a class / constructor function\n         *\n         * @param {object} thing\n         * @returns {ModelSchema} model schema\n         */\n        function getDefaultModelSchema(thing) {\n            if (!thing)\n                return null\n            if (isModelSchema(thing))\n                return thing\n            if (isModelSchema(thing.serializeInfo))\n                return thing.serializeInfo\n            if (thing.constructor && thing.constructor.serializeInfo)\n                return thing.constructor.serializeInfo\n        }\n\n        /**\n         * Sets the default model schema for class / constructor function.\n         * Everywhere where a model schema is required as argument, this class / constructor function\n         * can be passed in as well (for example when using `object` or `ref`.\n         *\n         * When passing an instance of this class to `serialize`, it is not required to pass the model schema\n         * as first argument anymore, because the default schema will be inferred from the instance type.\n         *\n         * @param {constructor|class} clazz class or constructor function\n         * @param {ModelSchema} modelSchema - a model schema\n         * @returns {ModelSchema} model schema\n         */\n        function setDefaultModelSchema(clazz, modelSchema) {\n            invariant(isModelSchema(modelSchema))\n            return clazz.serializeInfo = modelSchema\n        }\n\n        function isModelSchema(thing) {\n            return thing && thing.factory && thing.props\n        }\n\n        function isPropSchema(thing) {\n            return thing && thing.serializer && thing.deserializer\n        }\n\n        function isAliasedPropSchema(propSchema) {\n            return typeof propSchema === \"object\" && !!propSchema.jsonname\n        }\n\n        function isIdentifierPropSchema(propSchema) {\n            return  typeof propSchema === \"object\" && propSchema.identifier === true\n        }\n\n        function getIdentifierProp(modelSchema) {\n            invariant(isModelSchema(modelSchema))\n            // optimization: cache this lookup\n            while (modelSchema) {\n                for (var propName in modelSchema.props)\n                    if (typeof modelSchema.props[propName] === \"object\" && modelSchema.props[propName].identifier === true)\n                        return propName\n                modelSchema = modelSchema.extends\n            }\n            return null\n        }\n\n        function isAssignableTo(actualType, expectedType) {\n            while (actualType) {\n                if (actualType === expectedType)\n                    return true\n                actualType = actualType.extends\n            }\n            return false\n        }\n\n/*\n * ## Serialization and deserialization\n */\n\n        /**\n         * Serializes an object (graph) into json using the provided model schema.\n         * The model schema can be omitted if the object type has a default model schema associated with it.\n         * If a list of objects is provided, they should have an uniform type.\n         *\n         * @param arg1 modelschema to use. Optional\n         * @param arg2 object(s) to serialize\n         * @returns {object} serialized representation of the object\n         */\n        function serialize(arg1, arg2) {\n            invariant(arguments.length === 1 || arguments.length === 2, \"serialize expects one or 2 arguments\")\n            var thing = arguments.length === 1 ? arg1 : arg2\n            var schema = arguments.length === 1 ? null : arg1\n            if (Array.isArray(thing)) {\n                if (thing.length === 0)\n                    return [] // don't bother finding a schema\n                else if (!schema)\n                    schema = getDefaultModelSchema(thing[0])\n            } else if (!schema) {\n                schema = getDefaultModelSchema(thing)\n            }\n            invariant(!!schema, \"Failed to find default schema for \" + arg1)\n            if (Array.isArray(thing))\n                return thing.map(function (item) {\n                    return serializeWithSchema(schema, item)\n                })\n            return serializeWithSchema(schema, thing)\n        }\n\n        function serializeWithSchema(schema, obj) {\n            invariant(schema && typeof schema === \"object\", \"Expected schema\")\n            invariant(obj && typeof obj === \"object\", \"Expected object\")\n            var res\n            if (schema.extends)\n                res = serializeWithSchema(schema.extends, obj)\n            else {\n// TODO, make invariant?:  invariant(!obj.constructor.prototype.constructor.serializeInfo, \"object has a serializable supertype, but modelschema did not provide extends clause\")\n                res = {}\n            }\n            Object.keys(schema.props).forEach(function (key) {\n                var propDef = schema.props[key]\n                if (key === \"*\") {\n                    invariant(propDef === true, \"prop schema '*' can onle be used with 'true'\")\n                    serializeStarProps(schema, obj, res)\n                    return\n                }\n                if (propDef === true)\n                    propDef = _defaultPrimitiveProp\n                if (propDef === false)\n                    return\n                var jsonValue = propDef.serializer(obj[key], key, obj)\n                if (jsonValue === SKIP){\n                    return\n                }\n                res[propDef.jsonname || key] = jsonValue\n            })\n            return res\n        }\n\n        function serializeStarProps(schema, obj, target) {\n            for (var key in obj) if (obj.hasOwnProperty(key)) if (!(key in schema.props)) {\n                var value = obj[key]\n                // when serializing only serialize primitive props. Assumes other props (without schema) are local state that doesn't need serialization\n                if (isPrimitive(value))\n                    target[key] = value\n            }\n        }\n\n/*\n * Deserialization\n */\n\n        /**\n         * Deserializes a json structor into an object graph.\n         * This process might be asynchronous (for example if there are references with an asynchronous\n         * lookup function). The function returns an object (or array of objects), but the returned object\n         * might be incomplete until the callback has fired as well (which might happen immediately)\n         *\n         * @param {object|array} schema to use for deserialization\n         * @param {json} json data to deserialize\n         * @param {function} callback node style callback that is invoked once the deserializaiton has finished.\n         * First argument is the optional error, second argument is the deserialized object (same as the return value)\n         * @param {*} customArgs custom arguments that are available as `context.args` during the deserialization process. This can be used as dependency injection mechanism to pass in, for example, stores.\n         * @returns {object|array} deserialized object, possibly incomplete.\n         */\n        function deserialize(schema, json, callback, customArgs) {\n            invariant(arguments.length >= 2, \"deserialize expects at least 2 arguments\")\n            schema = getDefaultModelSchema(schema)\n            invariant(isModelSchema(schema), \"first argument should be model schema\")\n            if (Array.isArray(json)) {\n                var items = []\n                parallel(\n                    json,\n                    function (childJson, itemDone) {\n                        var instance = deserializeObjectWithSchema(null, schema, childJson, itemDone, customArgs)\n                        // instance is created synchronously so can be pushed\n                        items.push(instance)\n                    },\n                    callback || GUARDED_NOOP\n                )\n                return items\n            } else\n                return deserializeObjectWithSchema(null, schema, json, callback, customArgs)\n        }\n\n        function deserializeObjectWithSchema(parentContext, schema, json, callback, customArgs) {\n            if (json === null || json === undefined)\n                return void callback(null, null)\n            var context = new Context(parentContext, schema, json, callback, customArgs)\n            var target = schema.factory(context)\n            // todo async invariant\n            invariant(!!target, \"No object returned from factory\")\n// TODO: make invariant?            invariant(schema.extends || !target.constructor.prototype.constructor.serializeInfo, \"object has a serializable supertype, but modelschema did not provide extends clause\")\n            context.target = target\n            var lock = context.createCallback(GUARDED_NOOP)\n            deserializePropsWithSchema(context, schema, json, target)\n            lock()\n            return target\n        }\n\n        function deserializePropsWithSchema(context, schema, json, target) {\n            if (schema.extends)\n                deserializePropsWithSchema(context, schema.extends, json, target)\n            Object.keys(schema.props).forEach(function (propName) {\n                var propDef = schema.props[propName]\n                if (propName === \"*\") {\n                    invariant(propDef === true, \"prop schema '*' can onle be used with 'true'\")\n                    deserializeStarProps(schema, target, json)\n                    return\n                }\n                if (propDef === true)\n                    propDef = _defaultPrimitiveProp\n                if (propDef === false)\n                    return\n                var jsonAttr = propDef.jsonname || propName\n                if (!(jsonAttr in json))\n                    return\n                propDef.deserializer(\n                    json[jsonAttr],\n                    // for individual props, use root context based callbacks\n                    // this allows props to complete after completing the object itself\n                    // enabling reference resolving and such\n                    context.rootContext.createCallback(function (value) {\n                        if (value !== SKIP){\n                            target[propName] = value\n                        }\n                    }),\n                    context,\n                    target[propName] // initial value\n                )\n            })\n        }\n\n        function schemaHasAlias(schema, name) {\n            for (var key in schema.props)\n                if (typeof schema.props[key] === \"object\" && schema.props[key].jsonname === name)\n                    return true\n            return false\n        }\n\n        function deserializeStarProps(schema, obj, json) {\n            for (var key in json) if (!(key in schema.props) && !schemaHasAlias(schema, key)) {\n                var value = json[key]\n                // when deserializing we don't want to silently ignore 'unparseable data' to avoid confusing bugs\n                invariant(isPrimitive(value), \"encountered non primitive value while deserializing '*' properties in property '\" + key + \"': \" + value)\n                obj[key] = value\n            }\n        }\n\n        function Context(parentContext, modelSchema, json, onReadyCb, customArgs) {\n            this.parentContext = parentContext\n            this.isRoot = !parentContext\n            this.pendingCallbacks = 0\n            this.pendingRefsCount = 0\n            this.onReadyCb = onReadyCb || GUARDED_NOOP\n            this.json = json\n            this.target = null\n            this.hasError = false\n            this.modelSchema = modelSchema\n            if (this.isRoot) {\n                this.rootContext = this\n                this.args = customArgs\n                this.pendingRefs = {} // uuid: [{ modelSchema, uuid, cb }]\n                this.resolvedRefs = {} // uuid: [{ modelSchema, value }]\n            } else {\n                this.rootContext = parentContext.rootContext\n                this.args = parentContext.args\n            }\n        }\n        Context.prototype.createCallback = function (fn) {\n            this.pendingCallbacks++\n            // once: defend agains userland calling 'done' twice\n            return once(function(err, value) {\n                if (err) {\n                    if (!this.hasError) {\n                        this.hasError = true\n                        this.onReadyCb(err)\n                    }\n                } else if (!this.hasError) {\n                    fn(value)\n                    if (--this.pendingCallbacks === this.pendingRefsCount) {\n                        if (this.pendingRefsCount > 0)\n                            // all pending callbacks are pending reference resolvers. not good.\n                            this.onReadyCb(new Error(\n                                \"Unresolvable references in json: \\\"\" +\n                                Object.keys(this.pendingRefs).filter(function (uuid) {\n                                    return this.pendingRefs[uuid].length > 0\n                                }, this).join(\"\\\", \\\"\") +\n                                 \"\\\"\"\n                            ))\n                        else\n                            this.onReadyCb(null, this.target)\n                    }\n                }\n            }.bind(this))\n        }\n\n        // given an object with uuid, modelSchema, callback, awaits until the given uuid is available\n        // resolve immediately if possible\n        Context.prototype.await = function (modelSchema, uuid, callback) {\n            invariant(this.isRoot)\n            if (uuid in this.resolvedRefs) {\n                var match = this.resolvedRefs[uuid].filter(function (resolved) {\n                    return isAssignableTo(resolved.modelSchema, modelSchema)\n                })[0]\n                if (match)\n                    return void callback(null, match.value)\n            }\n            this.pendingRefsCount++\n            if (!this.pendingRefs[uuid])\n                this.pendingRefs[uuid] = []\n            this.pendingRefs[uuid].push({\n                modelSchema: modelSchema,\n                uuid: uuid,\n                callback: callback\n            })\n        }\n\n        // given a modelschema, uuid and value, resolve all references that where looking for this object\n        Context.prototype.resolve = function(modelSchema, uuid, value) {\n            invariant(this.isRoot)\n            if (!this.resolvedRefs[uuid])\n                this.resolvedRefs[uuid] = []\n            this.resolvedRefs[uuid].push({\n                modelSchema: modelSchema, value: value\n            })\n            if (uuid in this.pendingRefs) {\n                for (var i = this.pendingRefs[uuid].length - 1; i >= 0; i--) {\n                    var opts = this.pendingRefs[uuid][i]\n                    if (isAssignableTo(modelSchema, opts.modelSchema)) {\n                        this.pendingRefs[uuid].splice(i, 1)\n                        this.pendingRefsCount--\n                        opts.callback(null, value)\n                    }\n                }\n            }\n        }\n\n/*\n * Update\n */\n        /**\n         * Similar to deserialize, but updates an existing object instance.\n         * Properties will always updated entirely, but properties not present in the json will be kept as is.\n         * Further this method behaves similar to deserialize.\n         *\n         * @param {object} modelSchema, optional if it can be inferred from the instance type\n         * @param {object} target target instance to update\n         * @param {object} json the json to deserialize\n         * @param {function} callback the callback to invoke once deserialization has completed.\n         * @param {*} customArgs custom arguments that are available as `context.args` during the deserialization process. This can be used as dependency injection mechanism to pass in, for example, stores.\n         */\n        function update(modelSchema, target, json, callback, customArgs) {\n            var inferModelSchema =\n                arguments.length === 2 // only target and json\n                || typeof arguments[2] === \"function\" // callback as third arg\n\n            if (inferModelSchema) {\n                target = arguments[0]\n                modelSchema = getDefaultModelSchema(target)\n                json = arguments[1]\n                callback = arguments[2]\n                customArgs = arguments[3]\n            } else {\n                modelSchema = getDefaultModelSchema(modelSchema)\n            }\n            invariant(isModelSchema(modelSchema), \"update failed to determine schema\")\n            invariant(typeof target === \"object\" && target && !Array.isArray(target), \"update needs an object\")\n            var context = new Context(null, modelSchema, json, callback, customArgs)\n            context.target = target\n            var lock = context.createCallback(GUARDED_NOOP)\n            deserializePropsWithSchema(context, modelSchema, json, target)\n            lock()\n        }\n\n/*\n * ## Property schemas\n */\n\n        var _defaultPrimitiveProp = primitive()\n\n\n        /**\n         * Indicates that this field contains a primitive value (or Date) which should be serialized literally to json.\n         *\n         * @example\n         * createModelSchema(Todo, {\n         *   title: primitive()\n         * })\n         *\n         * console.dir(serialize(new Todo(\"test\")))\n         * // outputs: { title : \"test\" }\n         *\n         * @returns {ModelSchema}\n         */\n        function primitive() {\n            return {\n                serializer: function (value) {\n                    invariant(isPrimitive(value), \"this value is not primitive: \" + value)\n                    return value\n                },\n                deserializer: function (jsonValue, done) {\n                    if (!isPrimitive(jsonValue))\n                        return void done(\"[serializr] this value is not primitive: \" + jsonValue)\n                    return void done(null, jsonValue)\n                }\n            }\n        }\n\n        /**\n         *\n         *\n         * Similar to primitive, but this field will be marked as the identifier for the given Model type.\n         * This is used by for example `reference()` to serialize the reference\n         *\n         * Identifier accepts an optional `registerFn` with the signature:\n         * `(id, target, context) => void`\n         * that can be used to register this object in some store. note that not all fields of this object might\n         * have been deserialized yet.\n         *\n         * @example\n         * var todos = {};\n         *\n         * var s = _.createSimpleSchema({\n         *     id: _.identifier((id, object) => todos[id] = object),\n         *     title: true\n         * })\n         *\n         * _.deserialize(s, {\n         *     id: 1, title: \"test0\"\n         * })\n         * _.deserialize(s, [\n         *     { id: 2, title: \"test2\" },\n         *     { id: 1, title: \"test1\" }\n         * ])\n         *\n         * t.deepEqual(todos, {\n         *     1: { id: 1, title: \"test1\" },\n         *     2: { id: 2, title: \"test2\" }\n         * })\n         *\n         *\n         * @param {RegisterFunction} registerFn optional function to register this object during creation.\n         *\n         * @returns {PropSchema}\n         */\n        function identifier(registerFn) {\n            invariant(!registerFn || typeof registerFn === \"function\", \"First argument should be ommitted or function\")\n            return {\n                identifier: true,\n                serializer: _defaultPrimitiveProp.serializer,\n                deserializer: function (jsonValue, done, context) {\n                    _defaultPrimitiveProp.deserializer(jsonValue, function(err, id) {\n                        defaultRegisterFunction(id, context.target, context)\n                        if (registerFn)\n                            registerFn(id, context.target, context)\n                        done(err, id)\n                    })\n                }\n            }\n        }\n\n        function defaultRegisterFunction(id, value, context) {\n            context.rootContext.resolve(context.modelSchema, id, context.target)\n        }\n\n        /**\n         * Similar to primitive, serializes instances of Date objects\n         *\n         * @returns\n         */\n        function date() {\n            // TODO: add format option?\n            return {\n                serializer: function(value) {\n                    if (value === null || value === undefined)\n                        return value\n                    invariant(value instanceof Date, \"Expected Date object\")\n                    return value.getTime()\n                },\n                deserializer: function (jsonValue, done) {\n                    if (jsonValue === null || jsonValue === undefined)\n                        return void done(null, jsonValue)\n                    return void done(null, new Date(jsonValue))\n                }\n            }\n        }\n\n\n        /**\n         * Alias indicates that this model property should be named differently in the generated json.\n         * Alias should be the outermost propschema.\n         *\n         * @example\n         * createModelSchema(Todo, {\n         *   title: alias(\"task\", primitive())\n         * })\n         *\n         * console.dir(serialize(new Todo(\"test\")))\n         * // { task : \"test\" }\n         *\n         * @param {string} name name of the json field to be used for this property\n         * @param {PropSchema} propSchema propSchema to (de)serialize the contents of this field\n         * @returns {PropSchema}\n         */\n        function alias(name, propSchema) {\n            invariant(name && typeof name === \"string\", \"expected prop name as first argument\")\n            propSchema = (!propSchema || propSchema === true)  ? _defaultPrimitiveProp : propSchema\n            invariant(isPropSchema(propSchema), \"expected prop schema as second argument\")\n            invariant(!isAliasedPropSchema(propSchema), \"provided prop is already aliased\")\n            return {\n                jsonname: name,\n                serializer: propSchema.serializer,\n                deserializer: propSchema.deserializer,\n                identifier: isIdentifierPropSchema(propSchema)\n            }\n        }\n\n        /**\n         * Can be used to create simple custom propSchema.\n         *\n         * @example\n         * var schema = _.createSimpleSchema({\n         *   a: _.custom(\n         *     function(v) { return v + 2 },\n         *     function(v) { return v - 2 }\n         *   )\n         * })\n         * t.deepEqual(_.serialize(s, { a: 4 }), { a: 6 })\n         * t.deepEqual(_.deserialize(s, { a: 6 }), { a: 4 })\n         *\n         * @param {function} serializer function that takes a model value and turns it into a json value\n         * @param {function} deserializer function that takes a json value and turns it into a model value\n         * @returns {PropSchema}\n         */\n        function custom(serializer, deserializer) {\n            invariant(typeof serializer === \"function\", \"first argument should be function\")\n            invariant(typeof deserializer === \"function\", \"second argument should be function\")\n            return {\n                serializer: serializer,\n                deserializer: function (jsonValue, done) {\n                    done(null, deserializer(jsonValue))\n                }\n            }\n        }\n\n        /**\n         * `object` indicates that this property contains an object that needs to be (de)serialized\n         * using its own model schema.\n         *\n         * N.B. mind issues with circular dependencies when importing model schema's from other files! The module resolve algorithm might expose classes before `createModelSchema` is executed for the target class.\n         *\n         * @example\n         *\n         * class SubTask{}\n         * class Todo{}\n         *\n         * createModelSchema(SubTask, {\n         *   title: true\n         * });\n         * createModelSchema(Todo, {\n         *   title: true,\n         *   subTask: object(SubTask)\n         * });\n         *\n         * const todo = deserialize(Todo, {\n         *   title: \"Task\",\n         *   subTask: {\n         *     title: \"Sub task\"\n         *   }\n         * });\n         *\n         * @param {ModelSchema} modelSchema to be used to (de)serialize the object\n         * @returns {PropSchema}\n         */\n        function object(modelSchema) {\n            invariant(typeof modelSchema === \"object\" || typeof modelSchema === \"function\", \"No modelschema provided. If you are importing it from another file be aware of circular dependencies.\")\n            return {\n                serializer: function (item) {\n                    modelSchema = getDefaultModelSchema(modelSchema)\n                    invariant(isModelSchema(modelSchema), \"expected modelSchema, got \" + modelSchema)\n                    if (item === null || item === undefined)\n                        return item\n                    return serialize(modelSchema, item)\n                },\n                deserializer: function (childJson, done, context) {\n                    modelSchema = getDefaultModelSchema(modelSchema)\n                    invariant(isModelSchema(modelSchema), \"expected modelSchema, got \" + modelSchema)\n                    if (childJson === null || childJson === undefined)\n                        return void done(null, childJson)\n                    return void deserializeObjectWithSchema(context, modelSchema, childJson, done)\n                }\n            }\n        }\n\n        /**\n         * `reference` can be used to (de)serialize references that point to other models.\n         *\n         * The first parameter should be either a ModelSchema that has an `identifier()` property (see identifier)\n         * or a string that represents which attribute in the target object represents the identifier of the object.\n         *\n         * The second parameter is a lookup function that is invoked during deserialization to resolve an identifier to\n         * an object. Its signature should be as follows:\n         *\n         * `lookupFunction(identifier, callback, context)` where:\n         * 1. `identifier` is the identifier being resolved\n         * 2. `callback` is a node style calblack function to be invoked with the found object (as second arg) or an error (first arg)\n         * 3. `context` see context.\n         *\n         * The lookupFunction is optional. If it is not provided, it will try to find an object of the expected type and required identifier within the same JSON document\n         *\n         * N.B. mind issues with circular dependencies when importing model schemas from other files! The module resolve algorithm might expose classes before `createModelSchema` is executed for the target class.\n         *\n         * @example\n         *\n         *\n         * class User{}\n         * class Post{}\n         *\n         * createModelSchema(User, {\n         *   uuid: identifier(),\n         *   displayname: primitive()\n         * })\n         *\n         * createModelSchema(Post, {\n         *   author: reference(User, findUserById),\n         *   message: primitive()\n         * })\n         *\n         * function findUserById(uuid, callback) {\n         *   fetch(\"http://host/user/\" + uuid)\n         *     .then((userData) => {\n         *       deserialize(User, userData, callback)\n         *     })\n         *     .catch(callback)\n         * }\n         *\n         * deserialize(\n         *   Post,\n         *   {\n         *     message: \"Hello World\",\n         *     author: 234\n         *   },\n         *   (err, post) => {\n         *     console.log(post)\n         *   }\n         * )\n         *\n         * @param target: ModelSchema or string\n         * @param {RefLookupFunction} lookupFn function\n         * @returns {PropSchema}\n         */\n        function reference(target, lookupFn) {\n            invariant(!!target, \"No modelschema provided. If you are importing it from another file be aware of circular dependencies.\")\n            var initialized = false\n            var childIdentifierAttribute\n            function initialize() {\n                initialized = true\n                invariant(typeof target !== \"string\" || lookupFn, \"if the reference target is specified by attribute name, a lookup function is required\")\n                invariant(!lookupFn || typeof lookupFn === \"function\", \"second argument should be a lookup function\")\n                if (typeof target === \"string\")\n                    childIdentifierAttribute = target\n                else {\n                    var modelSchema = getDefaultModelSchema(target)\n                    invariant(isModelSchema(modelSchema), \"expected model schema or string as first argument for 'ref', got \" + modelSchema)\n                    lookupFn = lookupFn || createDefaultRefLookup(modelSchema)\n                    childIdentifierAttribute = getIdentifierProp(modelSchema)\n                    invariant(!!childIdentifierAttribute, \"provided model schema doesn't define an identifier() property and cannot be used by 'ref'.\")\n                }\n            }\n            return {\n                serializer: function (item) {\n                    if (!initialized)\n                        initialize()\n                    return item ? item[childIdentifierAttribute] : null\n                },\n                deserializer: function(identifierValue, done, context) {\n                    if (!initialized)\n                        initialize()\n                    if (identifierValue === null || identifierValue === undefined)\n                        done(null, identifierValue)\n                    else\n                        lookupFn(identifierValue, done, context)\n                }\n            }\n        }\n\n        function createDefaultRefLookup(modelSchema) {\n            return function resolve(uuid, cb, context) {\n                context.rootContext.await(modelSchema, uuid, cb)\n            }\n        }\n\n        /**\n         * List indicates that this property contains a list of things.\n         * Accepts a sub model schema to serialize the contents\n         *\n         * @example\n         *\n         * class SubTask{}\n         * class Task{}\n         * class Todo{}\n         *\n         * createModelSchema(SubTask, {\n         *   title: true\n         * })\n         * createModelSchema(Todo, {\n         *   title: true,\n         *   subTask: list(object(SubTask))\n         * })\n         *\n         * const todo = deserialize(Todo, {\n         *   title: \"Task\",\n         *   subTask: [{\n         *     title: \"Sub task 1\"\n         *   }]\n         * })\n         *\n         * @param {PropSchema} propSchema to be used to (de)serialize the contents of the array\n         * @returns {PropSchema}\n         */\n\n        function list(propSchema) {\n            propSchema = propSchema || _defaultPrimitiveProp\n            invariant(isPropSchema(propSchema), \"expected prop schema as second argument\")\n            invariant(!isAliasedPropSchema(propSchema), \"provided prop is aliased, please put aliases first\")\n            return {\n                serializer: function (ar) {\n                    invariant(ar && \"length\" in ar && \"map\" in ar, \"expected array (like) object\")\n                    return ar.map(propSchema.serializer)\n                },\n                deserializer: function(jsonArray, done, context) {\n                    if (!Array.isArray(jsonArray))\n                        return void done(\"[serializr] expected JSON array\")\n                    parallel(\n                        jsonArray,\n                        function (item, itemDone) {\n                            return propSchema.deserializer(item, itemDone, context)\n                        },\n                        done\n                    )\n                }\n            }\n        }\n\n        function isMapLike(thing) {\n            return thing && typeof thing.keys === \"function\" && typeof thing.clear === \"function\"\n        }\n\n        /**\n         * Similar to list, but map represents a string keyed dynamic collection.\n         * This can be both plain objects (default) or ES6 Map like structures.\n         * This will be inferred from the initial value of the targetted attribute.\n         *\n         * @param {*} propSchema\n         * @returns\n         */\n        function map(propSchema) {\n            propSchema = propSchema || _defaultPrimitiveProp\n            invariant(isPropSchema(propSchema), \"expected prop schema as second argument\")\n            invariant(!isAliasedPropSchema(propSchema), \"provided prop is aliased, please put aliases first\")\n            return {\n                serializer: function (m) {\n                    invariant(m && typeof m === \"object\", \"expected object or Map\")\n                    var isMap = isMapLike(m)\n                    var result = {}\n                    if (isMap)\n                        m.forEach(function(value, key) {\n                            result[key] = propSchema.serializer(value)\n                        })\n                    else for (var key in m)\n                        result[key] = propSchema.serializer(m[key])\n                    return result\n                },\n                deserializer: function(jsonObject, done, context, oldValue) {\n                    if (!jsonObject || typeof jsonObject !== \"object\")\n                        return void done(\"[serializr] expected JSON object\")\n                    var keys = Object.keys(jsonObject)\n                    list(propSchema).deserializer(\n                        keys.map(function (key) {\n                            return jsonObject[key]\n                        }),\n                        function (err, values) {\n                            if (err)\n                                return void done(err)\n                            var isMap = isMapLike(oldValue)\n                            var newValue\n                            if (isMap) {\n                                // if the oldValue is a map, we recycle it\n                                // there are many variations and this way we don't have to\n                                // know about the original constructor\n                                oldValue.clear()\n                                newValue = oldValue\n                            } else\n                                newValue = {}\n                            for (var i = 0, l = keys.length; i < l; i++)\n                                if (isMap)\n                                    newValue.set(keys[i], values[i])\n                                else\n                                    newValue[keys[i]] = values[i]\n                            done(null, newValue)\n                        },\n                        context\n                    )\n                }\n            }\n        }\n\n/*\n * UMD shizzle\n */\n        return {\n            createModelSchema: createModelSchema,\n            createSimpleSchema: createSimpleSchema,\n            setDefaultModelSchema: setDefaultModelSchema,\n            getDefaultModelSchema: getDefaultModelSchema,\n            serializable: serializable,\n            serialize: serialize,\n            serializeAll: serializeAll,\n            deserialize: deserialize,\n            update: update,\n            primitive: primitive,\n            identifier: identifier,\n            date: date,\n            alias: alias,\n            list: list,\n            map: map,\n            object: object,\n            child: object, // deprecate\n            reference: reference,\n            ref: reference, // deprecate\n            custom: custom,\n            SKIP: SKIP\n        }\n    }\n\n    // UMD\n    if (typeof exports === \"object\") {\n        module.exports = mrFactory()\n    } else if (typeof define === \"function\" && define.amd) {\n        define(\"serializr\", [], mrFactory)\n    } else {\n        g.serializr = mrFactory()\n    }\n})(function() { return this }())\n"}